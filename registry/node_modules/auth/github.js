var pkg = require('../../../package.json')
var _ = require('lodash')
var urlparser = require('github-url-parse')
var restify = require('restify')
var request = require('request')
var GitHubAPI = require('github-cache')

var config = require('config')
var pkgdal = require('dal/package')
var logger = require('logger').child({component: 'auth/github'})

function GitHubStrategy () {
  this.github = new GitHubAPI({
    version: '3.0.0',
    cachedb: config.auth.github.cache.path
  })

  return this
}

GitHubStrategy.prototype.userData = function () {
  var self = this

  return function GitHubUserData (req, res, next) {
    self.github.authenticate({
      type: 'oauth',
      token: req.auth.token
    })

    self.github.user.get({}, function (err, user) {
      if (err) {
        logger.error({err: err}, 'github api error')
        return next(err)
      }

      if (typeof user.login === 'undefined') {
        return next(new restify.UnauthorizedErrors('Invalid auth token or user login'))
      }

      req.auth.user = {
        user: user.login,
        name: user.name,
        email: user.email
      }

      logger.debug({user: req.auth.user}, 'user info')

      return next()
    })
  }
}

GitHubStrategy.prototype.checkAuth = function (permission) {
  var self = this

  if (['read', 'write'].indexOf(permission) === -1) {
    throw new Error('invalid permission')
  }

  return function GitHubCheckAuth (req, res, next) {
    if (typeof req.auth.token === 'undefined') {
      return next(new restify.UnauthorizedError('No valid auth token present'))
    }

    self.github.authenticate({
      type: 'oauth',
      token: req.auth.token
    })

    // 1. Check if we know about the package?
    //  -- if so then we can do auth from DataStore
    // 2. If we don't know the package, then check if we are publishing?
    //  -- if publishing, check the body contents and auth from data

    pkgdal.get(req.package.id, function (err, packageData) {
      if (err) {
        logger.error({err: err}, 'pkgdal.get error')
        return next(err)
      }

      // Package is Unknown, uses the data in the req.body
      if (_.isEmpty(packageData)) {
        return self._urlFromData(req.body, function (err, repoUrl) {
          if (err) {
            logger.error({err: err}, '_urlFromData error')
            return next(err)
          }

          self._verify(repoUrl, permission, next)
        })
      }

      self._urlFromDatastore(req.package.id, function (err, repoUrl) {
        if (err) {
          logger.error({err: err}, '_urlFromDatastore error')
          return next(err)
        }

        self._verify(repoUrl, permission, next)
      })
    })
  }
}

GitHubStrategy.prototype._urlFromData = function (pkgdata, callback) {
  var repo_url = null

  logger.info('_urlFromData')

  if (typeof pkgdata.repository !== 'undefined' && typeof pkgdata.repository.url !== 'undefined') {
    repo_url = pkgdata.repository.url
  }

  Object.keys(pkgdata.versions).forEach(function (v) {
    var packageData = pkgdata.versions[v]

    if (typeof packageData !== 'undefined' && typeof packageData.repository !== 'undefined' && typeof packageData.repository.url !== 'undefined' && repo_url === null) {
      repo_url = packageData.repository.url
    }
  })

  return callback(null, repo_url)
}

GitHubStrategy.prototype._urlFromDatastore = function (id, callback) {
  var repo_url = null

  logger.info('_urlFromDatastore')

  pkgdal.get(id, function (err, packageData) {
    if (err) {
      logger.error({err: err}, 'pkgdal.get error')
      return callback(err)
    }

    if (_.isEmpty(packageData)) {
      return callback(new Error('request was unauthorized'))
    }

    if (typeof packageData.repository !== 'undefined' && typeof packageData.repository.url !== 'undefined' && repo_url === null) {
      repo_url = packageData.repository.url
    }

    callback(null, repo_url)
  })
}

GitHubStrategy.prototype._verify = function (repo_url, permission, callback) {
  var self = this

  var map = {'write': 'push', 'read': 'pull', 'admin': 'admin'}

  if (repo_url.indexOf(config.auth.github.host) === -1) {
    return callback(new Error('Repository in package.json does not contain ' + config.auth.github.host + ', unable to authenticate'))
  }

  var repository = urlparser(repo_url)

  if (repository === null || (repository !== null && typeof repository.repo === 'undefined')) {
    return callback(new Error('Unable to parse repository url in package.json'))
  }

  repository.repo = repository.repo.replace('.git', '')

  self.github.repos.get({
    user: repository.user,
    repo: repository.repo
  }, function (err, repo) {
    if (err) {
      logger.error({err: err}, 'github.repos.get.error')
      return callback(err)
    }

    logger.debug({repo: repo}, 'repo')

    if (typeof repo.message !== 'undefined' && repo.message === 'Moved Permanently') {
      request.get({
        url: repo.url,
        headers: {
          'User-Agent': [pkg.name, pkg.version].join('/')
        }
      }, function (err, res, repo_json) {
        if (err) {
          return callback(self.sendError(res, 401, err))
        }

        try {
          var repo = JSON.parse(repo_json)
        } catch (e) {
          logger.error({err: e}, 'unable to parse json')
          return callback(e)
        }

        if (repo.permissions[map[permission]] === false) {
          return callback(new Error('Insufficient Permissions'))
        }

        return callback(null)
      })
    } else {
      if (typeof repo.permissions === 'undefined') {
        return callback(new Error('Unable to get repo permissions'))
      }

      if (repo.permissions[map[permission]] === false) {
        return callback(new Error('Insufficient Permissions'))
      }

      callback(null)
    }
  })
}

module.exports = GitHubStrategy
